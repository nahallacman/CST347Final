/* Note: To use the VTaskList Command you must modify the FreeRTOSConfig.h
 * to change #define configUSE_TRACE_FACILITY	0 to be a 1 */

#include "FreeRTOS.h"

#include "../../FreeRTOS-Plus-CLI/FreeRTOS_CLI.h"
#include "task.h"

#include "myCLICMD.h"
//#include "myTasks.h"
#include "myTasks.c"
#include "myTasks.h"

static const char taskListHdr[] = "\nName\tStat\tPri\tSpace\tTCB\r\n";

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static portBASE_TYPE prvTaskStatsCommand( int8_t *pcWriteBuffer,
 size_t xWriteBufferLen,
const int8_t *pcCommandString )
{
 /* For simplicity, this function assumes the output buffer is large enough
 to hold all the text generated by executing the vTaskList() API function,
 so the xWriteBufferLen parameter is not used. */
 ( void ) xWriteBufferLen;
 /* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
 generated by executing vTaskList() is written directly into the output
 buffer. */
 //vTaskList( pcWriteBuffer );
    sprintf(pcWriteBuffer, taskListHdr);
    pcWriteBuffer += strlen(taskListHdr);
    vTaskList(pcWriteBuffer);

 /* The entire table was written directly to the output buffer. Execution
 of this command is complete, so return pdFALSE. */
 return pdFALSE;
}

static const xCommandLineInput xTaskStatsCommand = {"task-stats",
            "task-stats:\r\n Displays a table of task state information\r\n",
            prvTaskStatsCommand,
            0};

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static portBASE_TYPE prvTaskStartLED( int8_t *pcWriteBuffer,
 size_t xWriteBufferLen,
const int8_t *pcCommandString )
{

    //assign message memory
    pxRxedMessage2 = &pxAllocMessage;




 /* For simplicity, this function assumes the output buffer is large enough
 to hold all the text generated by executing the vTaskList() API function,
 so the xWriteBufferLen parameter is not used. */
 ( void ) xWriteBufferLen;
 /* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
 generated by executing vTaskList() is written directly into the output
 buffer. */
 //vTaskList( pcWriteBuffer );
    //sprintf(pcWriteBuffer, taskListHdr);
    //pcWriteBuffer += strlen(taskListHdr);
    //vTaskList(pcWriteBuffer);
 int LEDnum = 0;
 int delayLength = 0;
 int8_t *pcParameter1, *pcParameter2;
portBASE_TYPE xParameter1StringLength, xParameter2StringLength, xResult;
 /* Obtain the name of the source file, and the length of its name, from
 the command string. The name of the source file is the first parameter. */
 pcParameter1 = FreeRTOS_CLIGetParameter
 (
 /* The command string itself. */
pcCommandString,
 /* Return the first parameter. */
 1,
/* Store the parameter string length. */
&xParameter1StringLength
 );
 /* Obtain the name of the destination file, and the length of its name. */
 pcParameter2 = FreeRTOS_CLIGetParameter( pcCommandString,
 2,
&xParameter2StringLength );

 LEDnum = atoi(pcParameter1) - 1; //adjust by 1 so D0 = LED1, D1 = LED2
 delayLength = atoi(pcParameter2);

 if(LEDnum >= 0 & LEDnum <= 2)
 {
     if(xLEDHandle[LEDnum] == NULL)
     {
         switch(LEDnum)
         {
             case 0:
                 xTaskCreate(taskToggleAnLED,
                        "LED1",
                        configMINIMAL_STACK_SIZE,
                        //(void *) &xTask3Parameters[currentHandle],
                        (void *) &xTask0Parameters,
                        LEDTASKPRIORITY,
                        &xLEDHandle[LEDnum]);

                    //send rate message to LED queue
                    pxRxedMessage2->LEDDelay = delayLength;
                    if( xQueueSendToBack(
                        xLEDQueue[LEDnum], //QueueHandle_t xQueue,
                        &pxRxedMessage2, //const void * pvItemToQueue,
                        0 //TickType_t xTicksToWait
                    ) != pdPASS )
                    {
                        //task was not able to be created after the xTicksToWait
                        //a = 0;
                    }

                        configASSERT( xLEDHandle[LEDnum] );
                        break;
             case 1:
                //create the corresponding LED task
                xTaskCreate(taskToggleAnLED,
                        "LED2",
                        configMINIMAL_STACK_SIZE,
                        //(void *) &xTask3Parameters[currentHandle],
                        (void *) &xTask1Parameters,
                        LEDTASKPRIORITY,
                        &xLEDHandle[LEDnum]);
                
                                 //send rate message to LED queue
                    pxRxedMessage2->LEDDelay = delayLength;
                    if( xQueueSendToBack(
                        xLEDQueue[LEDnum], //QueueHandle_t xQueue,
                        &pxRxedMessage2, //const void * pvItemToQueue,
                        0 //TickType_t xTicksToWait
                    ) != pdPASS )
                    {
                        //task was not able to be created after the xTicksToWait
                        //a = 0;
                    }

                        configASSERT( xLEDHandle[LEDnum] );
                 break;
             case 2:
                //create the corresponding LED task
                xTaskCreate(taskToggleAnLED,
                    "LED3",
                    configMINIMAL_STACK_SIZE,
                    //(void *) &xTask3Parameters[currentHandle],
                    (void *) &xTask2Parameters,
                    LEDTASKPRIORITY,
                    &xLEDHandle[LEDnum]);
                
                    //send rate message to LED queue
                    pxRxedMessage2->LEDDelay = delayLength;
                    if( xQueueSendToBack(
                        xLEDQueue[LEDnum], //QueueHandle_t xQueue,
                        &pxRxedMessage2, //const void * pvItemToQueue,
                        0 //TickType_t xTicksToWait
                    ) != pdPASS )
                    {
                        //task was not able to be created after the xTicksToWait
                        //a = 0;
                    }

                    configASSERT( xLEDHandle[LEDnum] );
                    break;
             default:
                 snprintf( pcWriteBuffer, xWriteBufferLen, "Error invalid LED #\r\n\r\n" );
         }
     }
     else
     {
         snprintf( pcWriteBuffer, xWriteBufferLen, "LED already started\r\n\r\n" );
     }
 }
 else
 {
     snprintf( pcWriteBuffer, xWriteBufferLen, "Error invalid argument\r\n\r\n" );
 }


 /* The entire table was written directly to the output buffer. Execution
 of this command is complete, so return pdFALSE. */
 return pdFALSE;
}

static const xCommandLineInput xTaskStartLED = {"start_led",
            "start_led: LED_int DELAY_ms\r\n Starts an LED blinking at the given rate. If already running, give message \"LED already started\"\r\n",
            prvTaskStartLED,
            2};
int

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static portBASE_TYPE prvTaskStopLED( int8_t *pcWriteBuffer,
 size_t xWriteBufferLen,
const int8_t *pcCommandString )
{
    int LEDnum;
 int8_t *pcParameter1;
 portBASE_TYPE xParameter1StringLength;
 /* Obtain the name of the source file, and the length of its name, from
 the command string. The name of the source file is the first parameter. */
 pcParameter1 = FreeRTOS_CLIGetParameter
 (
 /* The command string itself. */
pcCommandString,
 /* Return the first parameter. */
 1,
/* Store the parameter string length. */
&xParameter1StringLength
 );

LEDnum = atoi(pcParameter1) - 1;

 /* For simplicity, this function assumes the output buffer is large enough
 to hold all the text generated by executing the vTaskList() API function,
 so the xWriteBufferLen parameter is not used. */
 ( void ) xWriteBufferLen;
 /* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
 generated by executing vTaskList() is written directly into the output
 buffer. */
 //vTaskList( pcWriteBuffer );
//    sprintf(pcWriteBuffer, taskListHdr);
//    pcWriteBuffer += strlen(taskListHdr);
//    vTaskList(pcWriteBuffer);
 if(LEDnum >= 0 & LEDnum <= 2)
 {
     if(xLEDHandle[LEDnum] != NULL)
        {
            vTaskDelete(xLEDHandle[LEDnum]);
            //make sure to null out the handle after
            //( void ) xLEDHandle[LEDnum];
            xLEDHandle[LEDnum] = 0;
        }
     else
     {
        snprintf( pcWriteBuffer, xWriteBufferLen, "LED already stopped\r\n\r\n" );
     }
 }
 else
 {
     snprintf( pcWriteBuffer, xWriteBufferLen, "Error invalid argument\r\n\r\n" );
 }
 

 /* The entire table was written directly to the output buffer. Execution
 of this command is complete, so return pdFALSE. */
 return pdFALSE;
}

static const xCommandLineInput xTaskStopLED = {"stop_led",
            "stop_led: LED_int\r\n Stops the LED_int LED from blinking. If already stopped, give message \"LED already stopped\"\r\n",
            prvTaskStopLED,
            1};

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static portBASE_TYPE prvTaskChangeLED( int8_t *pcWriteBuffer,
 size_t xWriteBufferLen,
const int8_t *pcCommandString )
{
 int LEDnum = 0;
 int delayLength = 0;
 int8_t *pcParameter1, *pcParameter2;
portBASE_TYPE xParameter1StringLength, xParameter2StringLength, xResult;
 /* Obtain the name of the source file, and the length of its name, from
 the command string. The name of the source file is the first parameter. */
 pcParameter1 = FreeRTOS_CLIGetParameter
 (
 /* The command string itself. */
pcCommandString,
 /* Return the first parameter. */
 1,
/* Store the parameter string length. */
&xParameter1StringLength
 );
 /* Obtain the name of the destination file, and the length of its name. */
 pcParameter2 = FreeRTOS_CLIGetParameter( pcCommandString,
 2,
&xParameter2StringLength );
 
  /* For simplicity, this function assumes the output buffer is large enough
 to hold all the text generated by executing the vTaskList() API function,
 so the xWriteBufferLen parameter is not used. */    
( void ) xWriteBufferLen;
    //assign message memory
    pxRxedMessage2 = &pxAllocMessage;

 LEDnum = atoi(pcParameter1) - 1; //adjust by 1 so D0 = LED1, D1 = LED2
 delayLength = atoi(pcParameter2);
 
//check LED range
if(LEDnum >= 0 & LEDnum <= 2)
{
   if(xLEDHandle[LEDnum] != NULL)
    {
        //send rate message to LED queue
        pxRxedMessage2->LEDDelay = delayLength;
        if( xQueueSendToBack(
            xLEDQueue[LEDnum], //QueueHandle_t xQueue,
            &pxRxedMessage2, //const void * pvItemToQueue,
            0 //TickType_t xTicksToWait
        ) != pdPASS )
        {
            //task was not able to be created after the xTicksToWait
            //a = 0;
        }
    }
    else
    {
       snprintf( pcWriteBuffer, xWriteBufferLen, "LED is stopped\r\n\r\n" );
    }
}
else
{
    snprintf( pcWriteBuffer, xWriteBufferLen, "Error invalid LEDnum argument\r\n\r\n" );
}
 /* The entire table was written directly to the output buffer. Execution
 of this command is complete, so return pdFALSE. */
 return pdFALSE;
}

static const xCommandLineInput xTaskChangeLED = {"change_led",
            "change_led: LED_int DELAY_ms\r\n Changes the LED blinking rate. If not running, give message \"LED is stopped\"\r\n",
            prvTaskChangeLED,
            2};


void myCLI_init(void)
{
//delayLength = 0;

        const CLI_Command_Definition_t * const command = &xTaskStatsCommand;
       FreeRTOS_CLIRegisterCommand( command );
       const CLI_Command_Definition_t * const command2 = &xTaskStartLED;
       FreeRTOS_CLIRegisterCommand( command2 );
       const CLI_Command_Definition_t * const command3 = &xTaskStopLED;
       FreeRTOS_CLIRegisterCommand( command3 );
       const CLI_Command_Definition_t * const command4 = &xTaskChangeLED;
       FreeRTOS_CLIRegisterCommand( command4 );
}